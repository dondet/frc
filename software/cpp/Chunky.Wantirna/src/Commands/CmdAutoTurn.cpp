// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "CmdAutoTurn.h"
// #include "..\Custom\TurnPIDOutput.h"
// #include "..\Custom\GyroPIDSource.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

CmdAutoTurn::CmdAutoTurn(int Mode, double Power, double Angle): Command() {
    m_Power = Power;
    m_Angle = Angle;
    m_Mode = Mode;

    /*Set PID values, *-1 when going backwards
	if( m_Power > 0 )
	{
		p_constant = +0.001;
		i_constant = +0.0001;
		d_constant = +0;
	}
	else
	{
		p_constant = -0.001;
		i_constant = -0.0001;
		d_constant = 0;
	}

	//Set up PID controller
	TurnController = new PIDController(p_constant, i_constant, d_constant,static_cast<PIDSource*>( new GyroPIDSource()), new TurnPIDOutput(m_Power));
	TurnController->SetContinuous(true);
	TurnController->SetInputRange(-180,+180);
	TurnController->SetOutputRange(-0.5,+0.5);
	TurnController->SetSetpoint(m_Angle);

	*/



        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::subDriveBase.get());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void CmdAutoTurn::Initialize() {

//	Robot::subDriveBase->ResetAngle();

	// BEFORE PID CONTROL
//	startangle = Robot::subDriveBase->GetAngle();
    if( m_Mode == 0 )
    {
    	// sensor correction required because 360 degree turn is actually turning
    	// robot by slightly more than required
    	sensorcorrection = 0.965;
    	//correctedangle = m_Angle * sensorcorrection;
    	correctedangle = m_Angle;
    }
    else
    {
    	double pegx = Robot::subDriveBase->GetPegX();
    	double correction = -10 * (pegx + 0.2);
    	SmartDashboard::PutNumber("Peg X", pegx);
    	SmartDashboard::PutNumber("Correction", correction);
    	correctedangle = correction;
    }

	//Enable PID Control
	//TurnController->Enable();
}

// Called repeatedly when this Command is scheduled to run
void CmdAutoTurn::Execute() {

	// BEFORE PID CODE
//	gyro = -1 *  Robot::subDriveBase->GetAngle();
    anglenow = gyro - startangle;
    delta = correctedangle - anglenow;

    if( ( delta > powerdownthreshold ) || ( delta < -powerdownthreshold ) )
    {
        // set he power to the desired power
    	power = m_Power;
    }
    else
    {
    	// lets decrease the power as we approach the target angle ...
    	power = m_Power / 2;
    }

    if( delta > 0 )
    {
    	// we are heading in the right direction, keep going ...
        Robot::subDriveBase->Drive( m_Power , -1.0 );
    }
    else
    {
        // we have over shot, go back the other way ...
        Robot::subDriveBase->Drive( power, 1.0 );
    }


}

// Make this return true when this Command no longer needs to run execute()
bool CmdAutoTurn::IsFinished() {

	//BEFORE PID CONTROL
/*	gyro = -1 * Robot::subDriveBase->GetAngle();
    anglenow = gyro - startangle;
    SmartDashboard::PutNumber("Gyro", gyro);
    SmartDashboard::PutNumber("Angle now", anglenow);
    delta = correctedangle - anglenow;
    SmartDashboard::PutNumber("Delta", delta);
    SmartDashboard::PutNumber("Corrected Angle", correctedangle);
    return ( ( delta < allowederror ) && ( delta > -allowederror ) );
*/


	/*PID finishing control
	currentAngle = Robot::subDriveBase->GetAngle();
	timeToCorrect = 0;

	//If near required angle or too far, give 100 iterations to line up properly (for negative angles)
	if (m_Angle < 0){
		if( (currentAngle <= m_Angle) or  (currentAngle >= m_Angle + 10) ) {
			timeToCorrect += 1;
			if (timeToCorrect > 100) {
				return true;
			}
		}
		else {
			return false;
		}
	}

	//If near required angle or too far, give 100 iterations to line up properly (for positive angles)
	else if (m_Angle >= 0) {
		if( (currentAngle >= m_Angle) or (currentAngle <= (m_Angle - 10)) ) {
			timeToCorrect += 1;
			if (timeToCorrect > 100) {
				return true;
			}
			else {
				return false;
			}
		}
		else {
			return false;
		}
	}
	else {
		return false;
	}
*/
	return false;


	//return IsTimedOut();

}

// Called once after isFinished returns true
void CmdAutoTurn::End() {
//	TurnController->Disable();
    Robot::subDriveBase->Stop();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void CmdAutoTurn::Interrupted() {
    End();
}
